## **Переменные** 


Существует несколько вариантов определения переменной:

```go
var имя_переменной тип_данных
```

Именами переменной НЕ МОГУТ БЫТЬ ключевые слова языка: ```break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var```

Имя переменной может состоять из ```alphanumeric``` символов, а также из СИМВОЛА ПОДЧЕРКИВАНИЯ, при этом ПЕРВЫМ СИМВОЛОМ должен быть либо АЛФАВИТНЫЙ СИМВОЛ либо СИМВОЛ ПОДЧЕРКИВАНИЯю

Можно одновременно объявлять сразу несколько переменных через запятую:

```go
var a, b, c string
```
Также можно одновременно с объявлением, присвоить значение переменной:

```go
var a int = 1
```

Существует также такой вариант, при котором компилятор сам определяет тип присваемого значения:

```go
var a = 1
a := 5 // такой вариант доступен ТОЛЬКО ВНУТРИ ФУНКЦИЙ
```

Также можно сразу объявлять и присваивать значения нескольким переменным сгруппировав их:

```go
var (
    name string = "Berdi"
    age int = 23
)
```



### **Значение по умолчанию** 

Когда объявляется переменная и ей пока еще не присваевается значение, то она будет обладать значением по умолчанию в соответсвии со своим типом данных:

- для ```int``` это 0
- для ```float``` это 0.0
- для ```string``` это пустая строка
- для ```bool``` это ```false```
- для указателя это ```nil```


## **Чтение данных с консоли**

Для считывания данных с консоли применяется метод ```Scan``` из пакета ```fmt```, в качестве аргумента необходимо передать адрес переменной в которую мы хотим записавть значение переданное из консоли:

```go
var (
    name string
    age int
)

fmt.Scan(&string)
fmt.Scan(&int)
```

## **Вывод данных на консоль**

Для данных целей используются соответствующие методы из пакета ```fmt```:

- ```Println()``` - ставит пробелы если передаются несколько значение на вывод, плюс ставит новую строку


- ```Print()```  - не ставит пробел если среди передаваемых значений есть строка, в других случаях ставит пробел


## **Константы**

Константы это переменные значения которых не изменяются в программе:

```go
const pi float64 =  3.1415
```

Константы также можно объявлять в блоке:

```go
const (
    a int = 45
    b float32 = 3.3
)
```

Существует также вариант при котором если не указывается значение константы, то будет скопировано значение предыдущей константы:

```go
const (
    A int = 45
    B // B будет иметь значение 45
    C float32 = 3.3
    D // D будет иметь значение 3.3
)
```

### **Идентификатор ```iota```** 
 ```iota``` будет начинать с 0 и присваивать константам инкрементирующее значение:

```go
const (
    Sunday = iota // будет равен 0
    Monday
    Tuesday
    Wednesday // ...
    Thursday
    Friday
    Saturday // будет равен 6
)
```
если мы хотим пропустить какое-то значени, то можем использовать ```_```:

```go
const (
    Sunday = iota // будет равен 0
    Monday
    Tuesday
    Wednesday // ...
    Thursday
    Friday
    _
    Saturday // будет равен 7
)
```

## **Логические операции**

- ! (Операция отрицания, логическое НЕ). Инвертирует значение, то есть true --> false и false --> true:

```go
var a bool = true
var b bool = !a // false
var c bool = !b // true
```

- && (конъюнкция, логическое умножение, логическое И). Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.

```go
var b bool = 4 > 5 && 6 > 8   // false
var c bool = 3 <= 5 && 10 > 8 // true
```
- || (дизъюнкция, логическое сложение, логическое ИЛИ). Возвращает true, если хотя бы один операнд не равен false. Возвращает false, если оба операнда равны false.

```go
var b bool = 4 > 5 || 6 > 8      // false
var c bool = 3 == 5 || 10 > 8    // true
```


### **Условные конструкции**

Пример условной конструкции с if:
```go
package main

import "fmt"

func main() {
   a := 6    
   b := 7
   if a < b {     
      fmt.Println("a меньше, чем b")  
  }
}
```

Оператор ```if``` может начинаться с инструкции, которая будет выполнена перед проверкой условия. Переменные, объявленные в этом блоке, доступны только в области видимости которая существует до конца if:

```go
if v := math.Pow(x, n); v < lim {
    // ...
}
```

Если нужно проверить несколько условий то вместе с ```if``` используются ```else if``` и ```else```:

```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}
```

Существуют также оператор ```switch``` который упрощает условную конструкцию когда условий много:

```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

 Если в текущем case написать ```fallthrough```, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего case) условие:

 ```go
 v := 42
switch v {
case 100:
	fmt.Println(100)
	fallthrough
case 42:
	fmt.Println(42)
	fallthrough
case 1:
	fmt.Println(1)
	fallthrough
default:
	fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
 ```

 Существует специальная форма ```switch```, допускающая использование произвольных условий в каждом ```case```-блоке:

 ```go
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
	fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
	fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
	fmt.Println("от 1000 до 6000")
}
 ```