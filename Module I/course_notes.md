## **Переменные** 


Существует несколько вариантов определения переменной:

```go
var имя_переменной тип_данных
```

Именами переменной НЕ МОГУТ БЫТЬ ключевые слова языка: ```break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var```

Имя переменной может состоять из ```alphanumeric``` символов, а также из СИМВОЛА ПОДЧЕРКИВАНИЯ, при этом ПЕРВЫМ СИМВОЛОМ должен быть либо АЛФАВИТНЫЙ СИМВОЛ либо СИМВОЛ ПОДЧЕРКИВАНИЯ

Можно одновременно объявлять сразу несколько переменных через запятую:

```go
var a, b, c string
```
Также можно одновременно с объявлением, присвоить значение переменной:

```go
var a int = 1
```

Существует также такой вариант, при котором компилятор сам определяет тип присваемого значения:

```go
var a = 1
a := 5 // такой вариант доступен ТОЛЬКО ВНУТРИ ФУНКЦИЙ
```

Также можно сразу объявлять и присваивать значения нескольким переменным сгруппировав их:

```go
var (
    name string = "Berdi"
    age int = 23
)
```



### **Значение по умолчанию** 

Когда объявляется переменная и ей пока еще не присваевается значение, то она будет обладать значением по умолчанию в соответсвии со своим типом данных:

- для ```int``` это 0
- для ```float``` это 0.0
- для ```string``` это пустая строка
- для ```bool``` это ```false```
- для указателя это ```nil```


## **Чтение данных с консоли**

Для считывания данных с консоли применяется метод ```Scan``` из пакета ```fmt```, в качестве аргумента необходимо передать адрес переменной в которую мы хотим записавть значение переданное из консоли:

```go
var (
    name string
    age int
)

fmt.Scan(&string)
fmt.Scan(&int)
```

## **Вывод данных на консоль**

Для данных целей используются соответствующие методы из пакета ```fmt```:

- ```Println()``` - ставит пробелы если передаются несколько значение на вывод, плюс ставит новую строку


- ```Print()```  - не ставит пробел если среди передаваемых значений есть строка, в других случаях ставит пробел


## **Константы**

Константы это переменные значения которых не изменяются в программе:

```go
const pi float64 =  3.1415
```

Константы также можно объявлять в блоке:

```go
const (
    a int = 45
    b float32 = 3.3
)
```

Существует также вариант при котором если не указывается значение константы, то будет скопировано значение предыдущей константы:

```go
const (
    A int = 45
    B // B будет иметь значение 45
    C float32 = 3.3
    D // D будет иметь значение 3.3
)
```

### **Идентификатор ```iota```** 
 ```iota``` будет начинать с 0 и присваивать константам инкрементирующее значение:

```go
const (
    Sunday = iota // будет равен 0
    Monday
    Tuesday
    Wednesday // ...
    Thursday
    Friday
    Saturday // будет равен 6
)
```
если мы хотим пропустить какое-то значени, то можем использовать ```_```:

```go
const (
    Sunday = iota // будет равен 0
    Monday
    Tuesday
    Wednesday // ...
    Thursday
    Friday
    _
    Saturday // будет равен 7
)
```

## **Логические операции**

- ! (Операция отрицания, логическое НЕ). Инвертирует значение, то есть true --> false и false --> true:

```go
var a bool = true
var b bool = !a // false
var c bool = !b // true
```

- && (конъюнкция, логическое умножение, логическое И). Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.

```go
var b bool = 4 > 5 && 6 > 8   // false
var c bool = 3 <= 5 && 10 > 8 // true
```
- || (дизъюнкция, логическое сложение, логическое ИЛИ). Возвращает true, если хотя бы один операнд не равен false. Возвращает false, если оба операнда равны false.

```go
var b bool = 4 > 5 || 6 > 8      // false
var c bool = 3 == 5 || 10 > 8    // true
```


## **Условные конструкции**

Пример условной конструкции с if:
```go
package main

import "fmt"

func main() {
   a := 6    
   b := 7
   if a < b {     
      fmt.Println("a меньше, чем b")  
  }
}
```

Оператор ```if``` может начинаться с инструкции, которая будет выполнена перед проверкой условия. Переменные, объявленные в этом блоке, доступны только в области видимости которая существует до конца if:

```go
if v := math.Pow(x, n); v < lim {
    // ...
}
```

Если нужно проверить несколько условий то вместе с ```if``` используются ```else if``` и ```else```:

```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}
```

Существуют также оператор ```switch``` который упрощает условную конструкцию когда условий много:

```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

 Если в текущем case написать ```fallthrough```, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего case) условие:

 ```go
 v := 42
switch v {
case 100:
	fmt.Println(100)
	fallthrough
case 42:
	fmt.Println(42)
	fallthrough
case 1:
	fmt.Println(1)
	fallthrough
default:
	fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
 ```

 Существует специальная форма ```switch```, допускающая использование произвольных условий в каждом ```case```-блоке:

 ```go
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
	fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
	fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
	fmt.Println("от 1000 до 6000")
}
 ```

 ## **Циклы**

Единственным оператором цикла является оператор ```for```. Базовая форма цикла:
```go
for [инициализация счетчика]; [условие]; [изменение счётчика] {
    // действия
}
```
 Необязательно указывать ```[инициализация счетчика]; [условие]; [изменение счётчика]``` одновременно:
 



```go
var i = 1
for ; i < 10;{
    fmt.Println(i * i)
    i++
}
```

```go
var i = 1
for ; i < 10; i++{
    fmt.Println(i * i)
}
```

```go
var i = 1
for i < 10{
    fmt.Println(i * i)
    i++
}
```

Бесконечный цикл:

```go
for {

}
```

***Кстати***, иногда удобно пользоваться такой конструкцией ввода данных:

(но будьте осторожны, ведь мы не обрабатываем здесь ошибки)

```go
var n int
// считываем числа пока не будет введен 0
for fmt.Scan(&n); n != 0; fmt.Scan(&n){
	fmt.Println(n)
}
```

### Операторы ```break``` и ```continue```

```go
var sum = 0
 
for i := 1; i <= 10; i++{
    if i % 2 == 0 {
        continue        // переходим к следующей итерации
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 25
```

```go
var sum = 0
 
for i := 1; i <= 9; i++{
    if i > 4 {
        break       // если число больше 4 выходим из цикла
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 10
```

## **Форматированный вывод** ##

**Спецификаторы** для представления определенных типов данных:
- ```%t```: для вывода значение типа boolean (true или false)

- ```%b```: для вывода целых чисел в двоичной системе

- ```%c```: для вывода символов, представленных числовым кодом

- ```%d```: для вывода целых чисел в десятичной системе

- ```%o```: для вывода целых чисел в восьмеричной системе

- ```%q```: для вывода символов в одинарных кавычках

- ```%x```: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f

- ```%X```: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F

- ```%U```: для вывода символов в формате кодов Unicode, например, U+1234

- ```%e```: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78

- ```%E```: тоже самое что %e но в верхнем регистре, например, -1.234456E+78

- ```%f```: для вывода чисел с плавающей точкой, например, 123.456

- ```%F```: то же самое, что и %f

- ```%g```   %e для огромных экспонент, %f в противном случае

- ```%G```    %E для огромных экспонент, %F в противном случае

- ```%s```: для вывода строки

- ```%p```: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)

- ```%T``` для вывода типа переменной


К спецификаторам можно добавлять различные **флаги**, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое значение. Например, ```%9f``` - число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки: ```%.2f``` - две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:

- ```%f```: точность и ширина значения по умолчанию

- ```%9f```: ширина - 9 символов и точность по умолчанию
(число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)

- ```%.2f```: ширина по умолчанию и точность - 2 символа

- ```%9.2f```: ширина - 9 и точность - 2

- ```%9.f```: ширина - 9 и точность - 0

Также из флагов следует отметить дефис -, который дополняет значение пробелами не слева, как по умолчанию, а справа:

```go
var a = 3.14
fmt.Printf("|%8f|\n", a)
fmt.Printf("|%8.1f|\n", a)
fmt.Printf("|%8.3f|\n", a)
fmt.Printf("|%-8.3f|\n", a)
```

вывод:\
|3.140000|\
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1|\
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.140|\
|3.140&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|

Также есть функция Sprintf() которая работает как и Printf(), за исключением того что она ничего не печатает, а возвращает результат форматирования, рассмотрим пример:

```go
package main

import (
	"fmt"
)

func main() {
	var a float64 = 100.123456789
	result := fmt.Sprintf("%.2f", a)
	fmt.Printf("%q", result) // вывод: "100.12"
        // result будет типа string
}
```

**Литералы строк** - это строка которую мы видим в исходном коде программы включая кавычки
**Значения строк** - это строка которую мы видим после вывода в терминал

Например, в простой программе Hello, World! литерал строки будет выглядеть как ```"Hello, World!"```, а значением строки будет ```Hello, World!``` без кавычек.

Поскольку литералы строк и значения строк не эквивалентны, часто требуется добавлять в литералы строк дополнительное форматирование, чтобы значения строк отображались ожидаемым образом.
Также для форматирования строк используются управляющие символы. Управляющие символы интерпретируются кодом как имеющие особое значение. Управляющие символы начинаются с обратной косой черты /\, за которой идет другой символ строки, в результате чего строка имеет определенный формат.

Что, если нам не нужно особое форматирование строк? Например, нам может понадобиться сравнить или оценить несколько строк программного кода, где целенаправленно используется символ обратного слеша, так что мы не хотим, чтобы Go использовал этот символ как управляющий или как элемент экранирования.

Чистый литерал строки указывает Go игнорировать все форматирование строки, включая управляющие символы.

Мы можем создать чистую строку, заключив строку в обратные апострофы:

```fmt.Println(`Sammy says,\"The balloon\'s color is red.\"`)```

Output

```Sammy says,\"The balloon\'s color is red.\"```